generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum EventMemberStatus {
  listed
  invited
  accepted
  declined
  messaged
}

enum EventInvitePolicy {
  max_only
  prioritized
  exact
}

enum TimeSlotStatus {
  invites
  suggested
  accepted
  declined
}

enum MessageRole {
  user
  assistant
}

enum MessageDirection {
  inbound
  outbound
}

model User {
  user_id       String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  first_name    String
  last_name     String
  email         String?  @db.Text
  phone_number  String?  @unique @db.Text
  timezone      String
  created_date  DateTime @default(now()) @db.Timestamptz(6)
  modified_date DateTime @default(now()) @db.Timestamptz(6)

  activities Activity[]
  members    Member[]
  events     Event[]    @relation("EventCreatedBy")

  phoneAuthCodes PhoneAuthCode[]

  conversation Conversation?
}

model Activity {
  activity_id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id     String @db.Uuid
  name        String

  user   User    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  events Event[] @relation("ActivityEvents")

  @@index([user_id])
}

model Member {
  member_id    String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id      String  @db.Uuid
  first_name   String
  last_name    String
  phone_number String?
  email        String?
  location     String?

  user          User           @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  eventMembers  EventMember[]
  conversations Conversation[]

  @@index([user_id])
}

model Event {
  event_id           String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  created_by_user_id String  @db.Uuid
  activity_id        String? @db.Uuid
  location           String?

  /**
   * Free-text note/instruction to share with invited members.
   * Examples: "Wear black", "Bring water", "Meet by the north entrance".
   */
  invite_message String? @db.Text

  /** Max number of homies (does NOT include the user). */
  max_participants Int?

  /**
   * How invite constraints were specified at creation time.
   * - max_only: "invite any N" (no explicit list)
   * - prioritized: explicit list + capacity; fill remaining later
   * - exact: explicit list that is the full invite list
   */
  invite_policy EventInvitePolicy @default(max_only)

  createdBy     User           @relation("EventCreatedBy", fields: [created_by_user_id], references: [user_id], onDelete: Restrict)
  activity      Activity?      @relation("ActivityEvents", fields: [activity_id], references: [activity_id], onDelete: SetNull)
  eventMembers  EventMember[]
  timeSlots     TimeSlot[]
  conversations Conversation[]

  @@index([created_by_user_id])
  @@index([activity_id])
}

model EventMember {
  event_member_id String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  event_id        String            @db.Uuid
  member_id       String            @db.Uuid
  status          EventMemberStatus @default(listed)

  /** 1-based priority order for explicitly listed homies (optional). */
  priority_rank Int?

  event  Event  @relation(fields: [event_id], references: [event_id], onDelete: Cascade)
  member Member @relation(fields: [member_id], references: [member_id], onDelete: Cascade)

  @@unique([event_id, member_id])
  @@index([event_id])
  @@index([member_id])
}

model TimeSlot {
  time_slot_id String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  event_id     String         @db.Uuid
  start_time   DateTime       @db.Timestamptz(6)
  end_time     DateTime       @db.Timestamptz(6)
  status       TimeSlotStatus @default(suggested)

  event Event @relation(fields: [event_id], references: [event_id], onDelete: Cascade)

  @@index([event_id])
}

model PhoneAuthCode {
  id         String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user_id    String   @db.Uuid
  code       String
  created_at DateTime @default(now()) @db.Timestamptz(6)

  user User @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id])
  @@index([created_at])
}

model Conversation {
  conversation_id String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid

  /**
   * User <-> assistant conversation (1 per user).
   * Nullable so we can also support member invite conversations.
   */
  user_id String? @unique @db.Uuid

  /**
   * Member invite conversation (1 per event+member).
   * Nullable so we can keep supporting the existing per-user conversation.
   */
  event_id  String? @db.Uuid
  member_id String? @db.Uuid

  created_at DateTime @default(now()) @db.Timestamptz(6)
  updated_at DateTime @updatedAt @db.Timestamptz(6)

  // arbitrary agent memory (entities, summary, sentiment rollups)
  state Json?

  user   User?   @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  event  Event?  @relation(fields: [event_id], references: [event_id], onDelete: Cascade)
  member Member? @relation(fields: [member_id], references: [member_id], onDelete: Cascade)

  messages ConversationMessage[]

  @@unique([event_id, member_id])
  @@index([event_id])
  @@index([member_id])
}

model ConversationMessage {
  message_id      String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversation_id String @db.Uuid

  role      MessageRole
  direction MessageDirection
  content   String           @db.Text

  // Twilio MessageSid (unique so we can safely dedupe webhook retries)
  twilio_sid String? @unique @db.Text

  // sentiment, extracted intent/entities, moderation flags, etc.
  attributes Json?

  created_at DateTime @default(now()) @db.Timestamptz(6)

  conversation Conversation @relation(fields: [conversation_id], references: [conversation_id], onDelete: Cascade)

  @@index([conversation_id, created_at])
}
